import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, addDoc, onSnapshot, collection, query, serverTimestamp, orderBy, getDocs } from 'firebase/firestore';

// --- CONFIGURATION CONSTANTS (Gathered from user inputs) ---

// K's Kupcakes Business Info
const BUSINESS_INFO = {
    name: "K's Kupcakes",
    location: "Great Falls, Montana",
    phone: "(406) 799-0341",
    email: "kierstancostantino@yahoo.com",
    hours: "Always open (made-to-order)",
    zip: "59404",
};

// --- SECURITY SETTING: OWNER ACCESS KEY ---
// IMPORTANT: In a production environment, this key should be loaded from a secure environment variable.
// For demonstration, we will use a simple, memorable placeholder.
const OWNER_SECRET_KEY = "kupcakes123"; 

// LLM System Instruction based on business knowledge
// The instructions are designed to enforce a strict state machine: 
// 1. Get Type + Quantity + Time Slot -> 2. Generate 'order_lead' JSON + Dynamic Confirmation Text -> 3. Switch to 'conversational' mode permanently.
const SYSTEM_PROMPT = `You are 'Sprinkles', the friendly, professional, and knowledgeable AI assistant for K's Kupcakes in Great Falls, Montana.

**Persona Rules:**
1. Be cheerful, helpful, and concise. Use emojis sparingly but appropriately (e.g., üßÅ, üéÄ).
2. **Conversation Flow:** Always generate a unique, contextually relevant response unless the user's intent is clearly to place an order (see Ordering & JSON Output below).
3. If a user asks about a specific flavor, you MUST respond: 'We offer a wide variety of custom flavors for our Basic, Gourmet, and Mini Cupcakes! We discuss specific flavor combinations, like chocolate or strawberry, when you place your order, as everything is made-to-order!'

**K's Kupcakes Knowledge Base:**
- **Business Name:** K's Kupcakes
- **Location:** Great Falls, MT, 59404.
- **Service:** Homemade made-to-order cupcakes (Cupcake Shop/Bakery). The baker, K, handles delivery.
- **Contact Phone:** ${BUSINESS_INFO.phone}
- **Contact Email:** ${BUSINESS_INFO.email}
- **Hours:** Always open (by order/appointment).
- **Pricing:**
    - Basic: Half Dozen: $18, 1 Dozen: $30, 2 Dozen: $45.
    - Gourmet: Half Dozen: $25, 1 Dozen: $40, 2 Dozen: $55.
    - Mini: 1 Dozen: $30, 2 Dozen: $35, 3 Dozen: $40, 4 Dozen: $45.
- **Policies:**
    - Rush Orders (less than 48 hours): $25 minimum fee.
    - Deposit: 50% down required at booking.
    - Prices are subject to change based on designs/frosting colors.

**Ordering & JSON Output (CRITICAL RULES):**
- **Completeness Trigger (STRICT RULE):** You MUST only generate a structured JSON object detailing the order (responseType: 'order_lead') when the conversation history EXPLICITLY contains ALL THREE required pieces of information: 1) a specific **QUANTITY** (e.g., "half dozen", "1 dozen"), 2) a **CUPCAKE TYPE** ("Basic", "Gourmet", or "Mini"), AND 3) a **DATE/TIME SLOT** (e.g., "Saturday morning", "June 5th at 3 PM").
- **State Management (Conversational Mode):** If the user is placing an order but the Completeness Trigger is NOT met (responseType: 'conversational'):
    1. If Quantity or Type is missing, ask for the missing piece.
    2. If Quantity and Type ARE present but **Date/Time Slot is missing**, you MUST ask for the preferred date and time the order is needed by.
    3. In conversational responses, if order details (like Type/Quantity) have been gathered but not the time slot, you MUST include the captured details in the \`orderDetails\` object for continuity, but \`responseType\` must be 'conversational'.
- **Final Confirmation (STRICT \`order_lead\` Text):** When the Completeness Trigger IS met (responseType: 'order_lead'), your generated 'text' MUST perform two actions sequentially:
    1) Confirm the order, stating the specific type, quantity, and date/time captured.
    2) **CRITICAL CLOSING: You MUST end the text with the exact sentence: 'The baker will reach out to confirm the details and secure the required 50% deposit.'**
- **Location Restriction:** The generated 'text' MUST NOT mention 'Great Falls' or any logistical terms like 'delivery' or 'pickup'. K will confirm all logistics separately.
- **CRITICAL ANTI-REPETITION:** If your previous response used 'responseType: 'order_lead'', you MUST NOT generate another 'order_lead' JSON object in any subsequent response. Instead, you MUST use 'responseType: 'conversational'' and discuss final notes.

**OrderDetails Schema:**
- quantity: The total number of dozen(s) requested (e.g., 1, 2, 0.5, 4).
- type: 'Basic', 'Gourmet', or 'Mini'.
- notes: Any other details mentioned by the user (e.g., "for a birthday," "needs rush," "chocolate").
- pickupDateTime: The user's requested date and time for the order (e.g., "Saturday morning", "June 5th at 3 PM").
`;

// Firestore Collection Path
const ORDER_COLLECTION_PATH = (appId) => `artifacts/${appId}/public/data/orders`;

// --- Firebase and Gemini API Initialization/Hooks ---

// Global access to Canvas environment variables
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";

const useFirebase = () => {
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    useEffect(() => {
        if (!firebaseConfig) {
            console.error("Firebase config not available.");
            return;
        }

        try {
            const app = initializeApp(firebaseConfig);
            const firestore = getFirestore(app);
            const firebaseAuth = getAuth(app);
            
            console.log("Firebase App Initialized."); // DEBUG LOG
            setDb(firestore);
            setAuth(firebaseAuth);

            // Authentication Process
            const authenticate = async (authInstance) => {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(authInstance, initialAuthToken);
                    } else {
                        await signInAnonymously(authInstance);
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                }
            };

            const unsubscribe = onAuthStateChanged(firebaseAuth, (user) => {
                let currentUserId;
                if (user) {
                    currentUserId = user.uid;
                } else {
                    // Use a random ID for unauthenticated users (i.e., customers)
                    let tempUserId = localStorage.getItem('tempUserId');
                    if (!tempUserId) {
                        tempUserId = crypto.randomUUID();
                        localStorage.setItem('tempUserId', tempUserId);
                    }
                    currentUserId = tempUserId;
                }
                setUserId(currentUserId);
                setIsAuthReady(true);
                console.log("Auth Ready, User ID:", currentUserId); // DEBUG LOG
            });

            authenticate(firebaseAuth);
            return () => unsubscribe();
        } catch (e) {
            console.error("Firebase Initialization Error:", e);
        }
    }, [firebaseConfig, initialAuthToken]);

    return { db, auth, userId, isAuthReady };
};

const useChatbot = (db, userId, isAuthReady) => {
    const [messages, setMessages] = useState([]);
    const [isThinking, setIsThinking] = useState(false);
    const [orders, setOrders] = useState([]);

    const chatContainerRef = useRef(null);
    const hasInitialMessageBeenSet = useRef(false); // Ref to prevent double initial message

    // Scroll to bottom whenever messages update
    useEffect(() => {
        if (chatContainerRef.current) {
            chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
        }
    }, [messages]);

    // Initial Welcome Message
    useEffect(() => {
        // Only run if authentication is ready AND the message hasn't been set yet
        if (isAuthReady && !hasInitialMessageBeenSet.current) {
            setMessages([{
                // Use performance.now() for consistency
                id: performance.now(), 
                sender: 'Sprinkles',
                text: `Hi there! I'm Sprinkles üßÅ, the AI assistant for K's Kupcakes. How can I help you bake your day a little sweeter?`
            }]);
            hasInitialMessageBeenSet.current = true; // Set the flag so it doesn't run again
        }
    }, [isAuthReady]); // Only depends on auth readiness

    // Firestore Order Listener (Owner's View - runs only if DB is ready)
    useEffect(() => {
        if (db && isAuthReady) {
            const ordersRef = collection(db, ORDER_COLLECTION_PATH(appId));
            const q = query(ordersRef, orderBy('timestamp', 'desc'));

            const unsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedOrders = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                setOrders(fetchedOrders);
            }, (error) => {
                console.error("Error fetching orders:", error);
            });

            return () => unsubscribe();
        }
    }, [db, isAuthReady]);

    const saveOrderToFirestore = useCallback(async (orderData) => {
        if (!db) {
            console.error("Firestore not initialized.");
            return;
        }

        try {
            const ordersRef = collection(db, ORDER_COLLECTION_PATH(appId));
            await addDoc(ordersRef, {
                ...orderData,
                customerUserId: userId,
                timestamp: serverTimestamp(),
                status: 'New Lead',
            });
            console.log("Order saved successfully to Firestore.");
        } catch (e) {
            console.error("Error saving document: ", e);
            setMessages(prev => [...prev, {
                id: performance.now() + 100, // Ensure unique ID for error
                sender: 'Sprinkles',
                text: '‚ö†Ô∏è I encountered an error saving your order. We need the details to be saved digitally, so please try sending your last message again!'
            }]);
        }
    }, [db, userId]);

    const sendMessage = useCallback(async (text) => {
        if (isThinking) return;

        const newUserMessage = { id: performance.now(), sender: 'User', text }; 
        // 1. Start state update for UI
        setMessages(prev => [...prev, newUserMessage]);
        setIsThinking(true);

        // 2. Create history for API call using the current history + the new message
        const currentMessages = [...messages, newUserMessage];
        
        const chatHistory = currentMessages
            .filter(msg => typeof msg.text === 'string' && msg.text.trim().length > 0)
            .map(msg => ({
                role: msg.sender === 'User' ? 'user' : 'model',
                parts: [{ 
                    // We only send the text. 
                    text: msg.text 
                }]
            }));

        // CRITICAL: Check the *actual* last message saved to state to enforce Anti-Repetition logic 
        // We inject the state into the prompt so the LLM knows if an order has been created.
        const orderLeadGenerated = messages.some(msg => msg.responseType === 'order_lead');
        const updatedSystemPrompt = orderLeadGenerated 
            ? SYSTEM_PROMPT.replace(/(\*\*.CRITICAL ANTI-REPETITION:\*\*.+?)/, '$1\n\n**CRITICAL CURRENT STATE:** An order_lead has already been processed in this conversation. You MUST use responseType: \'conversational\'.')
            : SYSTEM_PROMPT;


        
        const payload = {
            contents: chatHistory,
            systemInstruction: {
                parts: [{ text: updatedSystemPrompt }]
            },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        responseType: {
                            type: "STRING",
                            description: "Either 'conversational' for general chat or 'order_lead' if the user is placing an order.",
                            enum: ["conversational", "order_lead"]
                        },
                        text: {
                            type: "STRING",
                            description: "The text response to be displayed to the user. This MUST follow the persona rules."
                        },
                        orderDetails: {
                            type: "OBJECT",
                            description: "Populate this object with captured details regardless of responseType (use null for missing fields).",
                            properties: {
                                quantity: { "type": "NUMBER", "description": "The number of dozens requested (e.g., 1, 2, 0.5, 4). Default to 1 if ambiguous." },
                                type: { "type": "STRING", "description": "Cupcake type: 'Basic', 'Gourmet', or 'Mini'." },
                                notes: { "type": "STRING", "description": "Summary of flavor or request details (e.g., 'for a birthday', 'needs rush', 'chocolate')." },
                                pickupDateTime: { "type": "STRING", "description": "The user's requested date and time for the order (e.g., 'Saturday morning', 'June 5th at 3 PM')." },
                            },
                            // All fields are required in the object structure, but the LLM uses null/empty string if not yet captured.
                            required: ["quantity", "type", "notes", "pickupDateTime"] 
                        }
                    },
                    required: ["responseType", "text"]
                }
            }
        };

        const executeApiCall = async (currentAttempt = 0) => {
            const maxRetries = 3;
            try {
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!jsonText) throw new Error("API returned no text content.");

                const parsedResponse = JSON.parse(jsonText);
                const { responseType, text: botText, orderDetails } = parsedResponse;

                // 3. Display Bot Response
                // Crucial: We attach responseType to the message object here so we can check it in the next turn
                const newBotMessage = { id: performance.now() + 1, sender: 'Sprinkles', text: botText, responseType };
                setMessages(prev => [...prev, newBotMessage]);

                // 4. Handle Order Lead
                // We save the order if the LLM explicitly returns 'order_lead' and details are present.
                if (responseType === 'order_lead' && orderDetails) {
                    await saveOrderToFirestore(orderDetails);
                    console.log("Order Lead Processed and Saved:", orderDetails);
                }

            } catch (error) {
                if (currentAttempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, currentAttempt) * 1000));
                    return executeApiCall(currentAttempt + 1);
                }
                console.error("Final API Call Error after retries:", error);
                setMessages(prev => [...prev, {
                    id: performance.now() + 2, // Ensure unique ID for error
                    sender: 'Sprinkles',
                    text: 'Oops! I had a little trouble reaching my brain. Please try your message again in a moment! üßê'
                }]);
            } finally {
                setIsThinking(false);
            }
        };

        executeApiCall();
    }, [messages, isThinking, saveOrderToFirestore]);

    return { messages, isThinking, sendMessage, chatContainerRef, orders, userId };
};

// --- UI Components ---

const ChatMessage = ({ sender, text }) => {
    const isBot = sender === 'Sprinkles';
    return (
        <div className={`flex mb-3 ${isBot ? 'justify-start' : 'justify-end'}`}>
            <div className={`max-w-4/5 p-3 rounded-xl shadow-lg transition-all duration-300 ${
                isBot
                    ? 'bg-pink-100 text-gray-800 rounded-bl-none'
                    : 'bg-pink-600 text-white rounded-br-none'
            }`}>
                <p className="font-semibold text-xs opacity-70 mb-1">{sender}</p>
                <div className="text-sm break-words whitespace-pre-wrap">{text}</div>
            </div>
        </div>
    );
};

const OrderCard = ({ order, index }) => {
    const timestamp = order.timestamp?.toDate().toLocaleString() || 'Loading...';
    return (
        <div className="bg-white p-4 mb-3 rounded-lg shadow-md border-l-4 border-pink-500">
            <div className="flex justify-between items-start mb-2 border-b pb-2">
                <h3 className="text-lg font-bold text-gray-800">{index + 1}. {order.type} Order</h3>
                <span className={`text-xs font-medium px-2 py-1 rounded-full ${order.status === 'New Lead' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}`}>
                    {order.status}
                </span>
            </div>
            <div className="text-sm space-y-1">
                <p>
                    <span className="font-semibold text-gray-600">Quantity:</span> {order.quantity} Dozen(s)
                </p>
                <p>
                    <span className="font-semibold text-gray-600">Needed By:</span> {order.pickupDateTime || 'N/A'}
                </p>
                <p>
                    <span className="font-semibold text-gray-600">Details:</span> {order.notes || 'No specific notes provided.'}
                </p>
                <p>
                    <span className="font-semibold text-gray-600">Customer ID:</span> <code className="text-xs break-all bg-gray-100 p-0.5 rounded">{order.customerUserId}</code>
                </p>
                <p className="text-xs text-gray-500 pt-1 border-t mt-2">
                    <span className="font-semibold">Time:</span> {timestamp}
                </p>
            </div>
        </div>
    );
};

const OwnerDashboard = ({ orders, userId, onLogout }) => {
    return (
        <div className="p-6 bg-gray-50 min-h-screen">
            <div className="max-w-4xl mx-auto">
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-3xl font-extrabold text-pink-700">üßÅ Order Lead Dashboard</h2>
                    <button
                        onClick={onLogout}
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-full text-sm font-medium hover:bg-gray-300 transition-colors"
                    >
                        &larr; Exit Owner View
                    </button>
                </div>

                <p className="text-gray-500 mb-6">
                    This private view tracks real-time customer leads captured by the 'Sprinkles' Chatbot.
                </p>

                <div className="bg-white shadow-xl rounded-xl p-4 mb-6">
                    <p className="text-sm font-medium text-gray-600">Current User ID (Owner Mode):</p>
                    <code className="text-xs break-all bg-gray-100 p-1 rounded block mt-1">{userId}</code>
                </div>

                {orders.length === 0 ? (
                    <div className="text-center p-10 bg-white rounded-lg shadow-inner text-gray-500">
                        <p className="text-lg font-medium">No New Leads Yet!</p>
                        <p className="text-sm">Leads will appear here instantly when a customer attempts to place an order.</p>
                    </div>
                ) : (
                    <div className="grid md:grid-cols-2 gap-4">
                        {orders.map((order, index) => (
                            <OrderCard key={order.id} order={order} index={index} />
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

const OwnerLogin = ({ onLogin, loginError }) => {
    const [key, setKey] = useState('');

    const handleSubmit = () => {
        if (key === OWNER_SECRET_KEY) {
            onLogin(true);
        } else {
            onLogin(false);
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            handleSubmit();
        }
    };

    return (
        <div className="absolute inset-0 bg-pink-50/90 backdrop-blur-sm flex items-center justify-center p-4 z-10">
            <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-sm border-t-4 border-pink-600">
                <h3 className="text-2xl font-bold text-gray-800 mb-2">Owner Access</h3>
                <p className="text-sm text-gray-500 mb-6">Enter the secret key to view the Order Dashboard.</p>

                <input
                    type="password"
                    value={key}
                    onChange={(e) => setKey(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder="Enter Secret Key"
                    className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none transition-shadow mb-4"
                />

                {loginError && (
                    <p className="text-red-500 text-sm mb-4">
                        ‚ùå Invalid key. Please try again.
                    </p>
                )}

                <button
                    onClick={handleSubmit}
                    className="w-full p-3 bg-pink-600 text-white font-semibold rounded-lg shadow-md hover:bg-pink-700 transition-colors"
                >
                    Unlock Dashboard
                </button>
            </div>
        </div>
    );
};


const ChatInterface = ({ messages, isThinking, sendMessage, chatContainerRef, onOwnerLoginClick }) => {
    const [input, setInput] = useState('');

    const handleSend = () => {
        if (input.trim() && !isThinking) {
            sendMessage(input.trim());
            setInput('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            handleSend();
        }
    };

    return (
        <div className="flex flex-col h-full bg-pink-50">
            {/* Header */}
            <div className="p-4 bg-pink-600 text-white shadow-lg flex items-center justify-between">
                <div className="flex items-center">
                    <span className="text-2xl mr-2">üßÅ</span>
                    <h1 className="text-xl font-bold">Sprinkles - K's Kupcakes AI</h1>
                </div>
                {/* Owner Login Button */}
                <button
                    onClick={onOwnerLoginClick}
                    className="px-3 py-1 bg-white text-pink-600 rounded-full text-xs font-semibold hover:bg-pink-100 transition-colors shadow"
                >
                    Owner Login üîë
                </button>
            </div>

            {/* Chat Messages */}
            <div ref={chatContainerRef} className="flex-1 p-4 overflow-y-auto custom-scrollbar">
                {messages.map((msg) => (
                    <ChatMessage key={msg.id} sender={msg.sender} text={msg.text} />
                ))}
                {isThinking && (
                    <div className="flex justify-start mb-3">
                        <div className="bg-pink-100 text-gray-800 p-3 rounded-xl rounded-bl-none shadow-lg animate-pulse">
                            <div className="dot-pulse"></div>
                        </div>
                    </div>
                )}
            </div>

            {/* Input Area */}
            <div className="p-4 bg-white border-t border-gray-200 shadow-inner">
                <div className="flex items-center space-x-2">
                    <input
                        type="text"
                        value={input}
                        onChange={(e) => setInput(e.target.value)}
                        onKeyDown={handleKeyDown}
                        placeholder="Ask about prices, hours, or place an order..."
                        className="flex-1 p-3 border border-pink-300 rounded-xl focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none transition-shadow"
                        disabled={isThinking}
                    />
                    <button
                        onClick={handleSend}
                        className={`p-3 rounded-xl text-white font-semibold shadow-md transition-all duration-300 ${
                            input.trim() && !isThinking
                                ? 'bg-pink-500 hover:bg-pink-700'
                                : 'bg-gray-300 cursor-not-allowed'
                        }`}
                        disabled={!input.trim() || isThinking}
                    >
                        {isThinking ? (
                            <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        ) : (
                            'Send'
                        )}
                    </button>
                </div>
            </div>
        </div>
    );
};

// --- Main App Component ---

const App = () => {
    const { db, userId, isAuthReady } = useFirebase();
    const { messages, isThinking, sendMessage, chatContainerRef, orders } = useChatbot(db, userId, isAuthReady);

    // State for managing view and owner access
    const [view, setView] = useState('chat'); // 'chat' or 'dashboard'
    const [isOwnerAuthenticated, setIsOwnerAuthenticated] = useState(false);
    const [showLoginModal, setShowLoginModal] = useState(false);
    const [loginError, setLoginError] = useState(false);

    const isLoading = !isAuthReady || !db;

    const handleLogin = (success) => {
        if (success) {
            setIsOwnerAuthenticated(true);
            setShowLoginModal(false);
            setView('dashboard');
            setLoginError(false);
        } else {
            setLoginError(true);
        }
    };

    const handleLogout = () => {
        setIsOwnerAuthenticated(false);
        setView('chat');
    };

    if (isLoading) {
        return (
            <div className="flex items-center justify-center min-h-screen bg-pink-100">
                <div className="text-center p-8 bg-white rounded-xl shadow-2xl">
                    <svg className="animate-spin h-8 w-8 text-pink-600 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p className="text-pink-700 font-semibold">Loading K's Kupcakes Assistant...</p>
                </div>
            </div>
        );
    }

    return (
        <div className="h-screen w-screen bg-gray-100 flex flex-col font-sans relative">
            <style jsx>{`
                /* Simple custom scrollbar for better visual integration */
                .custom-scrollbar::-webkit-scrollbar {
                    width: 6px;
                }
                .custom-scrollbar::-webkit-scrollbar-track {
                    background: #f1f1f1;
                }
                .custom-scrollbar::-webkit-scrollbar-thumb {
                    background: #fbcfe8; /* pink-200 */
                    border-radius: 3px;
                }
                .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                    background: #f472b6; /* pink-400 */
                }
                /* Loading dot animation for thinking state */
                .dot-pulse {
                    position: relative;
                    width: 10px;
                    height: 10px;
                    border-radius: 5px;
                    background-color: #f472b6; /* pink-400 */
                    color: #f472b6;
                    animation: dotPulse 1s infinite linear;
                    animation-delay: 0.25s;
                }
                .dot-pulse::before, .dot-pulse::after {
                    content: '';
                    display: inline-block;
                    position: absolute;
                    top: 0;
                    width: 10px;
                    height: 10px;
                    border-radius: 5px;
                    background-color: #f472b6;
                    color: #f472b6;
                }
                .dot-pulse::before {
                    left: -15px;
                    animation: dotPulseBefore 1s infinite linear;
                    animation-delay: 0s;
                }
                @keyframes dotPulseBefore {
                    0% { transform: scale(1); }
                    25% { transform: scale(0.9); }
                    50% { transform: scale(0.6); }
                    75% { transform: scale(0.9); }
                    100% { transform: scale(1); }
                }
                .dot-pulse::after {
                    right: -15px;
                    animation: dotPulseAfter 1s infinite linear;
                    animation-delay: 0.5s;
                }
                @keyframes dotPulse {
                    0% { transform: scale(1); }
                    25% { transform: scale(0.9); }
                    50% { transform: scale(0.6); }
                    75% { transform: scale(0.9); }
                    100% { transform: scale(1); }
                }
                @keyframes dotPulseAfter {
                    0% { transform: scale(1); }
                    25% { transform: scale(0.9); }
                    50% { transform: scale(0.6); }
                    75% { transform: scale(0.9); }
                    100% { transform: scale(1); }
                }
            `}</style>
            
            {/* Main Content Area */}
            <div className="flex-1 overflow-hidden">
                {view === 'chat' ? (
                    <ChatInterface
                        messages={messages}
                        isThinking={isThinking}
                        sendMessage={sendMessage}
                        chatContainerRef={chatContainerRef}
                        onOwnerLoginClick={() => {
                            setShowLoginModal(true);
                            setLoginError(false); // Reset error on showing modal
                        }}
                    />
                ) : (
                    <OwnerDashboard orders={orders} userId={userId} onLogout={handleLogout} />
                )}
            </div>

            {/* Owner Login Modal (only visible when requested) */}
            {showLoginModal && (
                <OwnerLogin
                    onLogin={handleLogin}
                    loginError={loginError}
                />
            )}
        </div>
    );
};

export default App;
